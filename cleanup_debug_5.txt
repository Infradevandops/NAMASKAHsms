/usr/local/lib/python3.11/site-packages/web3/__init__.py:2: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
  import pkg_resources
============================= test session starts ==============================
platform darwin -- Python 3.11.14, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/opt/python@3.11/bin/python3.11
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/Users/machine/Desktop/Namaskah. app/.hypothesis/examples'))
rootdir: /Users/machine/Desktop/Namaskah. app
configfile: pytest.ini
plugins: hypothesis-6.92.1, cov-4.1.0, asyncio-0.21.1, web3-6.11.3, anyio-3.7.1, langsmith-0.4.49
asyncio: mode=Mode.AUTO
collecting ... collected 1 item

tests/unit/test_notification_service.py::test_cleanup_old_notifications FAILED [100%]

=================================== FAILURES ===================================
________________________ test_cleanup_old_notifications ________________________

notification_service = <app.services.notification_service.NotificationService object at 0x111e28990>
test_user = <app.models.user.User object at 0x1121275d0>
db_session = <sqlalchemy.orm.session.Session object at 0x111d29090>

    def test_cleanup_old_notifications(notification_service, test_user, db_session):
        """Test cleaning up old notifications."""
        old_date = datetime.now(timezone.utc) - timedelta(days=40)
        note = Notification(
            user_id=test_user.id,
            type="old",
            title="Old",
            message="Msg",
            created_at=old_date,
            is_read=True
        )
        db_session.add(note)
        db_session.commit()
    
        # Verify it exists
        found = db_session.query(Notification).filter(Notification.id == note.id).first()
        assert found is not None
    
        # Verify filter matches
        cutoff = datetime.now(timezone.utc) - timedelta(days=30)
        # Note: timestamps might slightly differ, but 40 days is << 30 days.
        # In SQLite, date comparison relies on string format if not natively supported.
        # SQLAlchemy handles this usually.
        matched = db_session.query(Notification).filter(Notification.created_at < cutoff).count()
        assert matched >= 1
    
        count = notification_service.cleanup_old_notifications(days=30)
        assert count >= 1
    
        # Verify it's gone
>       left = db_session.query(Notification).filter(Notification.id == note.id).first()

tests/unit/test_notification_service.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:566: in __get__
    return self.impl.get(state, dict_)  # type: ignore[no-any-return]
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1086: in get
    value = self._fire_loader_callables(state, key, passive)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1116: in _fire_loader_callables
    return state._load_expired(state, passive)
/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/state.py:798: in _load_expired
    self.manager.expired_attribute_loader(self, toload, passive)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

mapper = <Mapper at 0x10ef400d0; Notification>
state = <sqlalchemy.orm.state.InstanceState object at 0x1117cfe30>
attribute_names = {'created_at', 'icon', 'id', 'is_read', 'link', 'message', ...}
passive = symbol('PASSIVE_OFF')

    def load_scalar_attributes(mapper, state, attribute_names, passive):
        """initiate a column-based attribute refresh operation."""
    
        # assert mapper is _state_mapper(state)
        session = state.session
        if not session:
            raise orm_exc.DetachedInstanceError(
                "Instance %s is not bound to a Session; "
                "attribute refresh operation cannot proceed" % (state_str(state))
            )
    
        no_autoflush = bool(passive & attributes.NO_AUTOFLUSH)
    
        # in the case of inheritance, particularly concrete and abstract
        # concrete inheritance, the class manager might have some keys
        # of attributes on the superclass that we didn't actually map.
        # These could be mapped as "concrete, don't load" or could be completely
        # excluded from the mapping and we know nothing about them.  Filter them
        # here to prevent them from coming through.
        if attribute_names:
            attribute_names = attribute_names.intersection(mapper.attrs.keys())
    
        if mapper.inherits and not mapper.concrete:
            # load based on committed attributes in the object, formed into
            # a truncated SELECT that only includes relevant tables.  does not
            # currently use state.key
            statement = mapper._optimized_get_statement(state, attribute_names)
            if statement is not None:
                # undefer() isn't needed here because statement has the
                # columns needed already, this implicitly undefers that column
                stmt = FromStatement(mapper, statement)
    
                return load_on_ident(
                    session,
                    stmt,
                    None,
                    only_load_props=attribute_names,
                    refresh_state=state,
                    no_autoflush=no_autoflush,
                )
    
        # normal load, use state.key as the identity to SELECT
        has_key = bool(state.key)
    
        if has_key:
            identity_key = state.key
        else:
            # this codepath is rare - only valid when inside a flush, and the
            # object is becoming persistent but hasn't yet been assigned
            # an identity_key.
            # check here to ensure we have the attrs we need.
            pk_attrs = [
                mapper._columntoproperty[col].key for col in mapper.primary_key
            ]
            if state.expired_attributes.intersection(pk_attrs):
                raise sa_exc.InvalidRequestError(
                    "Instance %s cannot be refreshed - it's not "
                    " persistent and does not "
                    "contain a full primary key." % state_str(state)
                )
            identity_key = mapper._identity_key_from_state(state)
    
        if (
            _none_set.issubset(identity_key) and not mapper.allow_partial_pks
        ) or _none_set.issuperset(identity_key):
            util.warn_limited(
                "Instance %s to be refreshed doesn't "
                "contain a full primary key - can't be refreshed "
                "(and shouldn't be expired, either).",
                state_str(state),
            )
            return
    
        result = load_on_ident(
            session,
            select(mapper).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL),
            identity_key,
            refresh_state=state,
            only_load_props=attribute_names,
            no_autoflush=no_autoflush,
        )
    
        # if instance is pending, a refresh operation
        # may not complete (even if PK attributes are assigned)
        if has_key and result is None:
>           raise orm_exc.ObjectDeletedError(state)
E           sqlalchemy.orm.exc.ObjectDeletedError: Instance '<Notification at 0x111e794d0>' has been deleted, or its row is otherwise not present.

/usr/local/lib/python3.11/site-packages/sqlalchemy/orm/loading.py:1661: ObjectDeletedError
----------------------------- Captured stdout call -----------------------------
2026-01-18 18:29:40,571 - app.services.notification_service - INFO - Deleted 1 notifications older than 30 days
------------------------------ Captured log call -------------------------------
INFO     app.services.notification_service:notification_service.py:303 Deleted 1 notifications older than 30 days
=============================== warnings summary ===============================
app/schemas/kyc.py:23
  /Users/machine/Desktop/Namaskah. app/app/schemas/kyc.py:23: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator("date_of_birth")

app/schemas/kyc.py:33
  /Users/machine/Desktop/Namaskah. app/app/schemas/kyc.py:33: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator("phone_number")

../../../../usr/local/lib/python3.11/site-packages/_pytest/config/__init__.py:1373
  /usr/local/lib/python3.11/site-packages/_pytest/config/__init__.py:1373: PytestConfigWarning: Unknown config option: env
  
    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/unit/test_notification_service.py::test_cleanup_old_notifications
======================== 1 failed, 3 warnings in 0.77s =========================
