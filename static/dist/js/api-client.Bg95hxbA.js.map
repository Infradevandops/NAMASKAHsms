{"version":3,"file":"api-client.Bg95hxbA.js","sources":["../../js/api-client.js"],"sourcesContent":["/**\n * Unified API Client\n * Single source of truth for all API calls with:\n * - Automatic auth headers\n * - Request timeouts\n * - Retry logic with exponential backoff\n * - Centralized error handling\n */\n\nimport { TIMEOUTS, HTTP_STATUS, STORAGE_KEYS } from './constants.js';\nimport { getAuthHeaders, hasAuthToken, clearAuth } from './auth-helpers.ts';\n\n/**\n * Custom API Error class\n */\nexport class ApiError extends Error {\n    constructor(message, status, data = null) {\n        super(message);\n        this.name = 'ApiError';\n        this.status = status;\n        this.data = data;\n    }\n\n    isUnauthorized() {\n        return this.status === HTTP_STATUS.UNAUTHORIZED;\n    }\n\n    isTimeout() {\n        return this.status === HTTP_STATUS.TIMEOUT;\n    }\n\n    isServerError() {\n        return this.status >= 500;\n    }\n}\n\n/**\n * API Client class\n */\nclass ApiClient {\n    constructor(options = {}) {\n        this.baseUrl = options.baseUrl || '/api/v1';\n        this.defaultTimeout = options.timeout || TIMEOUTS.API_REQUEST;\n        this.maxRetries = options.maxRetries || 3;\n        this.retryDelay = options.retryDelay || 1000;\n        this.onUnauthorized = options.onUnauthorized || this._defaultUnauthorizedHandler;\n    }\n\n    /**\n     * Default handler for 401 responses\n     */\n    _defaultUnauthorizedHandler() {\n        clearAuth();\n        window.location.href = '/auth/login';\n    }\n\n    /**\n     * Calculate retry delay with exponential backoff\n     */\n    _getRetryDelay(attempt) {\n        return Math.min(this.retryDelay * Math.pow(2, attempt), 10000);\n    }\n\n    /**\n     * Sleep for specified milliseconds\n     */\n    _sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n     * Make an API request\n     * @param {string} endpoint - API endpoint\n     * @param {Object} options - Request options\n     * @returns {Promise<any>}\n     */\n    async request(endpoint, options = {}) {\n        const {\n            method = 'GET',\n            body,\n            headers = {},\n            timeout = this.defaultTimeout,\n            retry = true,\n            maxRetries = this.maxRetries,\n            requiresAuth = true\n        } = options;\n\n        // Check auth if required\n        if (requiresAuth && !hasAuthToken()) {\n            throw new ApiError('No authentication token', HTTP_STATUS.UNAUTHORIZED);\n        }\n\n        const url = `${this.baseUrl}${endpoint}`;\n        let lastError;\n\n        for (let attempt = 0; attempt <= (retry ? maxRetries : 0); attempt++) {\n            // Wait before retry (skip first attempt)\n            if (attempt > 0) {\n                const delay = this._getRetryDelay(attempt - 1);\n                if (window.FrontendLogger) {\n                    window.FrontendLogger.info(`API retry ${attempt}/${maxRetries} for ${url}, waiting ${delay}ms`);\n                }\n                await this._sleep(delay);\n            }\n\n            // Create abort controller for timeout\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n            try {\n                const requestHeaders = {\n                    'Content-Type': 'application/json',\n                    ...getAuthHeaders(),\n                    ...headers\n                };\n\n                const requestOptions = {\n                    method,\n                    headers: requestHeaders,\n                    credentials: 'include',\n                    signal: controller.signal\n                };\n\n                if (body && method !== 'GET') {\n                    requestOptions.body = typeof body === 'string' ? body : JSON.stringify(body);\n                }\n\n                if (window.FrontendLogger) {\n                    window.FrontendLogger.logApiCall(method, url);\n                }\n\n                const response = await fetch(url, requestOptions);\n                clearTimeout(timeoutId);\n\n                if (window.FrontendLogger) {\n                    window.FrontendLogger.logApiResponse(method, url, response.status);\n                }\n\n                // Handle 401 Unauthorized\n                if (response.status === HTTP_STATUS.UNAUTHORIZED) {\n                    this.onUnauthorized();\n                    throw new ApiError('Unauthorized', HTTP_STATUS.UNAUTHORIZED);\n                }\n\n                // Don't retry client errors (except 408, 429)\n                if (response.status >= 400 && response.status < 500 &&\n                    response.status !== HTTP_STATUS.TIMEOUT &&\n                    response.status !== HTTP_STATUS.TOO_MANY_REQUESTS) {\n                    const errorData = await response.json().catch(() => ({}));\n                    throw new ApiError(\n                        errorData.detail || `HTTP ${response.status}`,\n                        response.status,\n                        errorData\n                    );\n                }\n\n                // Retry on server errors\n                if (response.status >= 500 ||\n                    response.status === HTTP_STATUS.TIMEOUT ||\n                    response.status === HTTP_STATUS.TOO_MANY_REQUESTS) {\n                    lastError = new ApiError(`HTTP ${response.status}`, response.status);\n                    if (attempt < maxRetries) continue;\n                    throw lastError;\n                }\n\n                // Success - parse response\n                const contentType = response.headers.get('content-type');\n                if (contentType && contentType.includes('application/json')) {\n                    return await response.json();\n                }\n                return await response.text();\n\n            } catch (error) {\n                clearTimeout(timeoutId);\n\n                // Handle abort (timeout)\n                if (error.name === 'AbortError') {\n                    lastError = new ApiError('Request timeout', HTTP_STATUS.TIMEOUT);\n                    if (attempt < maxRetries) continue;\n                    throw lastError;\n                }\n\n                // Re-throw ApiErrors\n                if (error instanceof ApiError) {\n                    throw error;\n                }\n\n                // Network errors - retry\n                lastError = new ApiError(error.message || 'Network error', 0);\n                if (attempt < maxRetries) continue;\n                throw lastError;\n            }\n        }\n\n        throw lastError;\n    }\n\n    /**\n     * GET request\n     */\n    get(endpoint, options = {}) {\n        return this.request(endpoint, { ...options, method: 'GET' });\n    }\n\n    /**\n     * POST request\n     */\n    post(endpoint, body, options = {}) {\n        return this.request(endpoint, { ...options, method: 'POST', body });\n    }\n\n    /**\n     * PUT request\n     */\n    put(endpoint, body, options = {}) {\n        return this.request(endpoint, { ...options, method: 'PUT', body });\n    }\n\n    /**\n     * PATCH request\n     */\n    patch(endpoint, body, options = {}) {\n        return this.request(endpoint, { ...options, method: 'PATCH', body });\n    }\n\n    /**\n     * DELETE request\n     */\n    delete(endpoint, options = {}) {\n        return this.request(endpoint, { ...options, method: 'DELETE' });\n    }\n}\n\n// Create default instance\nexport const api = new ApiClient();\n\n// Export class for custom instances\nexport { ApiClient };\n\n// For non-module scripts (IIFE compatibility)\nif (typeof window !== 'undefined') {\n    window.ApiClient = ApiClient;\n    window.ApiError = ApiError;\n    window.api = api;\n}\n"],"names":["ApiError","Error","constructor","message","status","data","super","this","name","isUnauthorized","HTTP_STATUS","UNAUTHORIZED","isTimeout","TIMEOUT","isServerError","ApiClient","options","baseUrl","defaultTimeout","timeout","TIMEOUTS","API_REQUEST","maxRetries","retryDelay","onUnauthorized","_defaultUnauthorizedHandler","clearAuth","window","location","href","_getRetryDelay","attempt","Math","min","pow","_sleep","ms","Promise","resolve","setTimeout","request","endpoint","method","body","headers","retry","requiresAuth","hasAuthToken","url","lastError","delay","FrontendLogger","info","controller","AbortController","timeoutId","abort","requestOptions","getAuthHeaders","credentials","signal","JSON","stringify","logApiCall","response","fetch","clearTimeout","logApiResponse","TOO_MANY_REQUESTS","errorData","json","catch","detail","contentType","get","includes","text","error","post","put","patch","api"],"mappings":"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"}