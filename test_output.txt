============================= test session starts ==============================
platform darwin -- Python 3.11.14, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/opt/python@3.11/bin/python3.11
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/Users/machine/Desktop/Namaskah. app/.hypothesis/examples'))
rootdir: /Users/machine/Desktop/Namaskah. app
configfile: pytest.ini
plugins: hypothesis-6.92.1, cov-4.1.0, asyncio-0.21.1, anyio-3.7.1, langsmith-0.4.49
asyncio: mode=Mode.AUTO
collecting ... collected 11 items

tests/unit/test_auth_service.py::TestAuthService::test_register_user_success ERROR [  9%]
tests/unit/test_auth_service.py::TestAuthService::test_register_user_duplicate_email ERROR [ 18%]
tests/unit/test_auth_service.py::TestAuthService::test_register_user_with_referral ERROR [ 27%]
tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_success ERROR [ 36%]
tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_wrong_password ERROR [ 45%]
tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_not_found ERROR [ 54%]
tests/unit/test_auth_service.py::TestAuthService::test_create_and_verify_api_key ERROR [ 63%]
tests/unit/test_auth_service.py::TestAuthService::test_verify_api_key_invalid ERROR [ 72%]
tests/unit/test_auth_service.py::TestAuthService::test_deactivate_api_key ERROR [ 81%]
tests/unit/test_auth_service.py::TestAuthService::test_reset_password_flow ERROR [ 90%]
tests/unit/test_auth_service.py::TestAuthService::test_reset_password_invalid_token ERROR [100%]

==================================== ERRORS ====================================
_________ ERROR at setup of TestAuthService.test_register_user_success _________

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d5814d0>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d5814d0>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d5814d0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d5814d0>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10d16b310>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d16b310>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d50fe30>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
bind = <sqlalchemy.engine.base.Connection object at 0x10d16b310>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d16b310>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
connection = <sqlalchemy.engine.base.Connection object at 0x10d16b310>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d16b310>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d582950>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d5739d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d5814d0>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
_____ ERROR at setup of TestAuthService.test_register_user_duplicate_email _____

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e128190>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e128190>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e128190>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e128190>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10e5b6890>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e5b6890>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d56d770>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
bind = <sqlalchemy.engine.base.Connection object at 0x10e5b6890>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e5b6890>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
connection = <sqlalchemy.engine.base.Connection object at 0x10e5b6890>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e5b6890>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e128050>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10e052650>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e128190>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
______ ERROR at setup of TestAuthService.test_register_user_with_referral ______

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e79b110>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e79b110>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e79b110>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e79b110>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10d5b1290>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d5b1290>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
bind = <sqlalchemy.engine.base.Connection object at 0x10d5b1290>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d5b1290>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
connection = <sqlalchemy.engine.base.Connection object at 0x10d5b1290>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d5b1290>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e79aad0>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10e79a2d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e79b110>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
_______ ERROR at setup of TestAuthService.test_authenticate_user_success _______

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e7a8d90>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e7a8d90>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e7a8d90>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e7a8d90>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10e5b4390>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e5b4390>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d591e00>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
bind = <sqlalchemy.engine.base.Connection object at 0x10e5b4390>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e5b4390>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
connection = <sqlalchemy.engine.base.Connection object at 0x10e5b4390>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e5b4390>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e7abf50>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10dfc1c90>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e7a8d90>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
___ ERROR at setup of TestAuthService.test_authenticate_user_wrong_password ____

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d933150>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d933150>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d933150>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d933150>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10d5a1910>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d5a1910>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10defacb0>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
bind = <sqlalchemy.engine.base.Connection object at 0x10d5a1910>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d5a1910>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
connection = <sqlalchemy.engine.base.Connection object at 0x10d5a1910>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d5a1910>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d933b10>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d9338d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d933150>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
______ ERROR at setup of TestAuthService.test_authenticate_user_not_found ______

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e1d8bd0>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e1d8bd0>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e1d8bd0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e1d8bd0>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10e1d89d0>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e1d89d0>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03da90>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
bind = <sqlalchemy.engine.base.Connection object at 0x10e1d89d0>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e1d89d0>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
connection = <sqlalchemy.engine.base.Connection object at 0x10e1d89d0>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e1d89d0>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e1d9bd0>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10c4bfb90>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e1d8bd0>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
_______ ERROR at setup of TestAuthService.test_create_and_verify_api_key _______

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10de8b710>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10de8b710>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10de8b710>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10de8b710>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10de8a790>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10de8a790>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d545fe0>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
bind = <sqlalchemy.engine.base.Connection object at 0x10de8a790>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10de8a790>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
connection = <sqlalchemy.engine.base.Connection object at 0x10de8a790>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10de8a790>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10de88b10>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10de8af50>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10de8b710>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
________ ERROR at setup of TestAuthService.test_verify_api_key_invalid _________

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e104550>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e104550>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e104550>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e104550>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10e1043d0>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e1043d0>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69c230>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
bind = <sqlalchemy.engine.base.Connection object at 0x10e1043d0>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e1043d0>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
connection = <sqlalchemy.engine.base.Connection object at 0x10e1043d0>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e1043d0>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e105650>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d4ec110>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e104550>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
__________ ERROR at setup of TestAuthService.test_deactivate_api_key ___________

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d8cb190>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d8cb190>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d8cb190>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d8cb190>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10d8cb250>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d8cb250>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e69fca0>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
bind = <sqlalchemy.engine.base.Connection object at 0x10d8cb250>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d8cb250>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
connection = <sqlalchemy.engine.base.Connection object at 0x10d8cb250>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d8cb250>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d8c8d90>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10c2652d0>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d8cb190>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
__________ ERROR at setup of TestAuthService.test_reset_password_flow __________

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e161010>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e161010>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e161010>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e161010>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10e160790>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e160790>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10d5f45f0>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
bind = <sqlalchemy.engine.base.Connection object at 0x10e160790>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e160790>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
connection = <sqlalchemy.engine.base.Connection object at 0x10e160790>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10e160790>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10e161490>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10e162d50>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10e161010>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError
_____ ERROR at setup of TestAuthService.test_reset_password_invalid_token ______

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:139: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d9738d0>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
obj = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d9738d0>
kwargs = {'first_pk': False}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d9738d0>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
kw = {'first_pk': False}
meth = <bound method DDLCompiler.visit_create_column of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
create = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d9738d0>
first_pk = False, kw = {}
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)

    def visit_create_column(self, create, first_pk=False, **kw):
        column = create.element
    
        if column.system:
            return None
    
>       text = self.get_column_specification(column, first_pk=first_pk)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
column = Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)
kwargs = {'first_pk': False}

    def get_column_specification(self, column, **kwargs):
>       coltype = self.dialect.type_compiler_instance.process(
            column.type, type_expression=column
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/dialects/sqlite/base.py:1534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
type_ = JSONB(astext_type=Text())
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
        if (
            type_._variant_mapping
            and self.dialect.name in type_._variant_mapping
        ):
            type_ = type_._variant_mapping[self.dialect.name]
>       return type_._compiler_dispatch(self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
>           return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:962: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="function")
    def db_session():
        """Create a new database session for a test."""
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MetaData(), bind = Engine(sqlite:///:memory:), tables = None
checkfirst = True

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        """Create all tables stored in this metadata.
    
        Conditional by default, will not attempt to recreate tables already
        present in the target database.
    
        :param bind:
          A :class:`.Connection` or :class:`.Engine` used to access the
          database.
    
        :param tables:
          Optional list of ``Table`` objects, which is a subset of the total
          tables in the ``MetaData`` (others are ignored).
    
        :param checkfirst:
          Defaults to True, don't issue CREATEs for tables already present
          in the target database.
    
        """
>       bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(sqlite:///:memory:)
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}
conn = <sqlalchemy.engine.base.Connection object at 0x10d973a90>

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        with self.begin() as conn:
>           conn._run_ddl_visitor(visitorcallable, element, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d973a90>
visitorcallable = <class 'sqlalchemy.sql.ddl.SchemaGenerator'>
element = MetaData(), kwargs = {'checkfirst': True, 'tables': None}

    def _run_ddl_visitor(
        self,
        visitorcallable: Type[Union[SchemaGenerator, SchemaDropper]],
        element: SchemaItem,
        **kwargs: Any,
    ) -> None:
        """run a DDL visitor.
    
        This method is only here so that the MockConnection can change the
        options given to the visitor so that "checkfirst" is skipped.
    
        """
>       visitorcallable(self.dialect, self, **kwargs).traverse_single(element)

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>
obj = MetaData(), kw = {}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>
meth = <bound method SchemaGenerator.visit_metadata of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        collection = sort_tables_and_constraints(
            [t for t in tables if self._can_create_table(t)]
        )
    
        seq_coll = [
            s
            for s in metadata._sequences.values()
            if s.column is None and self._can_create_sequence(s)
        ]
    
        event_collection = [t for (t, fks) in collection if t is not None]
    
        with self.with_ddl_events(
            metadata,
            tables=event_collection,
            checkfirst=self.checkfirst,
        ):
            for seq in seq_coll:
                self.traverse_single(seq, create_ok=True)
    
            for table, fkcs in collection:
                if table is not None:
>                   self.traverse_single(
                        table,
                        create_ok=True,
                        include_foreign_key_constraints=fkcs,
                        _is_metadata_operation=True,
                    )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>
obj = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
kw = {'_is_metadata_operation': True, 'create_ok': True, 'include_foreign_key_constraints': {ForeignKeyConstraint(<sqlalche...pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None))}}
v = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>
meth = <bound method SchemaGenerator.visit_table of <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>>

    def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
        for v in self.visitor_iterator:
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
            if meth:
>               return meth(obj, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.SchemaGenerator object at 0x10e03d770>
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
create_ok = True, include_foreign_key_constraints = None
_is_metadata_operation = True

    def visit_table(
        self,
        table,
        create_ok=False,
        include_foreign_key_constraints=None,
        _is_metadata_operation=False,
    ):
        if not create_ok and not self._can_create_table(table):
            return
    
        with self.with_ddl_events(
            table,
            checkfirst=self.checkfirst,
            _is_metadata_operation=_is_metadata_operation,
        ):
            for column in table.columns:
                if column.default is not None:
                    self.traverse_single(column.default)
    
            if not self.dialect.supports_alter:
                # e.g., don't omit any foreign key constraints
                include_foreign_key_constraints = None
    
            CreateTable(
                table,
                include_foreign_key_constraints=(
                    include_foreign_key_constraints
                ),
>           )._invoke_with(self.connection)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:957: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
bind = <sqlalchemy.engine.base.Connection object at 0x10d973a90>

    def _invoke_with(self, bind):
        if self._should_execute(self.target, bind):
>           return bind.execute(self)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d973a90>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
parameters = None

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
connection = <sqlalchemy.engine.base.Connection object at 0x10d973a90>
distilled_params = (), execution_options = immutabledict({})

    def _execute_on_connection(
        self, connection, distilled_params, execution_options
    ):
>       return connection._execute_ddl(
            self, distilled_params, execution_options
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10d973a90>
ddl = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
distilled_parameters = (), execution_options = immutabledict({})

    def _execute_ddl(
        self,
        ddl: ExecutableDDLElement,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a schema.DDL object."""
    
        execution_options = ddl._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        event_multiparams: Optional[_CoreMultiExecuteParams]
        event_params: Optional[_CoreSingleExecuteParams]
    
        if self._has_events or self.engine._has_events:
            (
                ddl,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                ddl, distilled_parameters, execution_options
            )
        else:
            event_multiparams = event_params = None
    
        exec_opts = self._execution_options.merge_with(execution_options)
        schema_translate_map = exec_opts.get("schema_translate_map", None)
    
        dialect = self.dialect
    
>       compiled = ddl.compile(
            dialect=dialect, schema_translate_map=schema_translate_map
        )

/usr/local/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>, bind = None
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[Union[Engine, Connection]] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        """Compile this SQL expression.
    
        The return value is a :class:`~.Compiled` object.
        Calling ``str()`` or ``unicode()`` on the returned value will yield a
        string representation of the result. The
        :class:`~.Compiled` object also can return a
        dictionary of bind parameter names and values
        using the ``params`` accessor.
    
        :param bind: An :class:`.Connection` or :class:`.Engine` which
           can provide a :class:`.Dialect` in order to generate a
           :class:`.Compiled` object.  If the ``bind`` and
           ``dialect`` parameters are both omitted, a default SQL compiler
           is used.
    
        :param column_keys: Used for INSERT and UPDATE statements, a list of
            column names which should be present in the VALUES clause of the
            compiled statement. If ``None``, all columns from the target table
            object are rendered.
    
        :param dialect: A :class:`.Dialect` instance which can generate
            a :class:`.Compiled` object.  This argument takes precedence over
            the ``bind`` argument.
    
        :param compile_kwargs: optional dictionary of additional parameters
            that will be passed through to the compiler within all "visit"
            methods.  This allows any custom flag to be passed through to
            a custom compilation construct, for example.  It is also used
            for the case of passing the ``literal_binds`` flag through::
    
                from sqlalchemy.sql import table, column, select
    
                t = table('t', column('x'))
    
                s = select(t).where(t.c.x == 5)
    
                print(s.compile(compile_kwargs={"literal_binds": True}))
    
        .. seealso::
    
            :ref:`faq_sql_expression_string`
    
        """
    
        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                default = util.preloaded.engine_default
                dialect = default.StrCompileDialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()
    
>       return self._compiler(dialect, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
kw = {'schema_translate_map': None}

    def _compiler(self, dialect, **kw):
        """Return a compiler appropriate for this ClauseElement, given a
        Dialect."""
    
>       return dialect.ddl_compiler(dialect, self, **kw)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/ddl.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10d118550>
statement = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
schema_translate_map = None, render_schema_translate = False
compile_kwargs = immutabledict({})

    def __init__(
        self,
        dialect: Dialect,
        statement: Optional[ClauseElement],
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        render_schema_translate: bool = False,
        compile_kwargs: Mapping[str, Any] = util.immutabledict(),
    ):
        """Construct a new :class:`.Compiled` object.
    
        :param dialect: :class:`.Dialect` to compile against.
    
        :param statement: :class:`_expression.ClauseElement` to be compiled.
    
        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL
    
         .. seealso::
    
            :ref:`schema_translating`
    
        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.
    
    
        """
        self.dialect = dialect
        self.preparer = self.dialect.identifier_preparer
        if schema_translate_map:
            self.schema_translate_map = schema_translate_map
            self.preparer = self.preparer._with_schema_translate(
                schema_translate_map
            )
    
        if statement is not None:
            self.state = CompilerState.COMPILING
            self.statement = statement
            self.can_execute = statement.supports_execution
            self._annotations = statement._annotations
            if self.can_execute:
                if TYPE_CHECKING:
                    assert isinstance(statement, Executable)
                self.execution_options = statement._execution_options
>           self.string = self.process(self.statement, **compile_kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:867: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
obj = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>, kwargs = {}

    def process(self, obj: Visitable, **kwargs: Any) -> str:
>       return obj._compiler_dispatch(self, **kwargs)

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:912: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
kw = {}
meth = <bound method DDLCompiler.visit_create_table of <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>>

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
            meth = getter(visitor)
        except AttributeError as err:
            return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
        else:
>           return meth(self, **kw)  # type: ignore  # noqa: E501

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/visitors.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10d970810>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x10d973050>, kw = {}
table = Table('pricing_templates', MetaData(), Column('id', Integer(), table=<pricing_templates>, primary_key=True, nullable=F...e=<pricing_templates>), Column('template_metadata', JSONB(astext_type=Text()), table=<pricing_templates>), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x10d1186d0>
text = '\nCREATE TABLE pricing_templates (\n\tid INTEGER NOT NULL, \n\tname VARCHAR(100) NOT NULL, \n\tdescription TEXT, \n\t... TIMESTAMP DEFAULT (CURRENT_TIMESTAMP), \n\tcreated_by VARCHAR, \n\teffective_date TIMESTAMP, \n\texpires_at TIMESTAMP'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x10d9738d0>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'pricing_templates', column 'template_metadata'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x10d118750> can't render element of type JSONB

/usr/local/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py:6497: CompileError

--------- coverage: platform darwin, python 3.11.14-final-0 ----------
Name                                                Stmts   Miss  Cover   Missing
---------------------------------------------------------------------------------
app/__init__.py                                         0      0   100%
app/api/__init__.py                                     0      0   100%
app/api/admin/__init__.py                               2      0   100%
app/api/admin/actions.py                               45     25    44%   17-24, 32-39, 47-55, 66-68, 92-94, 104-106
app/api/admin/admin.py                                213    213     0%   3-597
app/api/admin/admin_router.py                          89     56    37%   22-25, 31-34, 38-41, 50-51, 71-77, 85-91, 99-106, 114-118, 139-158, 172-179
app/api/admin/alerts.py                                24     24     0%   3-40
app/api/admin/analytics.py                             22      9    59%   16-21, 29-30, 38-39
app/api/admin/analytics_monitoring.py                  30     30     0%   3-60
app/api/admin/audit_compliance.py                     105     82    22%   21-24, 38-73, 84-136, 144-239, 250-278, 286
app/api/admin/compliance.py                            11     11     0%   3-20
app/api/admin/dashboard.py                             51     30    41%   30-72, 82-110, 118-137
app/api/admin/dependencies.py                          10      4    60%   12-15
app/api/admin/disaster_recovery.py                     20     20     0%   3-41
app/api/admin/export.py                                58     40    31%   24-67, 82-110, 125-153
app/api/admin/infrastructure.py                        25     25     0%   3-52
app/api/admin/kyc.py                                  107    107     0%   3-282
app/api/admin/logging_dashboard.py                     65     38    42%   28-39, 46-58, 63-73, 83-86, 96-99, 109-112, 122-149, 164-170
app/api/admin/monitoring.py                            29     29     0%   3-63
app/api/admin/pricing_control.py                       97     58    40%   38-72, 85-128, 137-158, 167-184, 191-197, 225-232, 251-420
app/api/admin/router.py                                28      0   100%
app/api/admin/stats.py                                 39     26    33%   19-77, 97-115
app/api/admin/support.py                              154    154     0%   3-433
app/api/admin/tier_management.py                      177    137    23%   38-41, 47-63, 75-107, 118-159, 169-206, 214-245, 253-276, 286-319, 330-360
app/api/admin/user_management.py                      124    101    19%   19-22, 34-69, 80-123, 134-166, 174-195, 206-236, 244-265
app/api/admin/verification_actions.py                  48     34    29%   18-39, 51-57, 91-111
app/api/admin/verification_analytics.py                67     46    31%   21-24, 37-71, 79-117, 140-178, 194-221
app/api/admin/verification_history.py                  98     76    22%   22-25, 39-84, 92-120, 130-172, 184-236
app/api/billing/credit_endpoints.py                   141    110    22%   47-64, 92-110, 130-143, 168-191, 215-241, 269-299, 321-342
app/api/billing/payment_endpoints.py                  238    205    14%   33-38, 62-146, 172-251, 264-458, 482-533, 551-571, 577-582
app/api/billing/payment_history_endpoints.py           96     74    23%   40-57, 78-91, 118-139, 163-195, 223-238, 261-274
app/api/billing/pricing_endpoints.py                   23     11    52%   21-38, 46-57, 63-71
app/api/billing/refund_endpoints.py                    66     46    30%   43-67, 88-101, 126-139, 162-182
app/api/billing/router.py                              14      0   100%
app/api/billing/tier_endpoints.py                     122    101    17%   24-57, 67-172, 182-236, 244-265
app/api/core/__init__.py                                0      0   100%
app/api/core/affiliate_endpoints.py                    37     18    51%   29-34, 42-58, 66-78, 94-97
app/api/core/analytics_enhanced.py                     64     45    30%   31-132, 142-191, 201-241
app/api/core/api_key_endpoints.py                      55     33    40%   25-32, 52-68, 83-95, 103-111, 126-131
app/api/core/auth.py                                  284    234    18%   55-143, 149-150, 167-168, 175-307, 315-366, 372-380, 386-401, 407-414, 420-429, 443-448, 462-464, 485-493, 503-511, 517-614
app/api/core/auth_enhanced.py                          48     48     0%   3-106
app/api/core/balance_sync.py                           94     68    28%   26-27, 33-71, 77-82, 88-98, 108-109, 119-157, 167-179, 187-210
app/api/core/blacklist.py                              69     69     0%   3-201
app/api/core/countries.py                              62     47    24%   15, 24-79, 84, 140-185, 191-204, 210-236
app/api/core/dashboard_activity.py                     26     14    46%   23-60
app/api/core/forwarding.py                            153    153     0%   3-401
app/api/core/gdpr.py                                   27     17    37%   18-58, 66-77
app/api/core/notification_endpoints.py                 33     17    48%   20-28, 39-51, 57-63, 71-83
app/api/core/notifications.py                          45     45     0%   3-130
app/api/core/preferences.py                            33     21    36%   20-25, 40-71
app/api/core/provider_health.py                        30     30     0%   3-42
app/api/core/router.py                                 36      0   100%
app/api/core/services.py                               23     14    39%   17-34, 41-57
app/api/core/setup.py                                  28     28     0%   3-60
app/api/core/system.py                                 44      8    82%   34, 38, 44, 55, 61, 67, 78, 88
app/api/core/textverified_balance.py                   15      6    60%   19-27
app/api/core/user_profile.py                           10      2    80%   17-19
app/api/core/user_settings.py                          84     57    32%   35-53, 65-84, 96-116, 125-130, 142-163, 173-183
app/api/core/user_settings_endpoints.py                52     35    33%   29-47, 57-89
app/api/core/waitlist.py                               38     38     0%   1-57
app/api/core/wallet.py                                143    109    24%   43-57, 67-88, 98-125, 131-156, 168-183, 193-249, 259-320
app/api/notifications/__init__.py                       0      0   100%
app/api/notifications/notification_endpoints.py        99     99     0%   3-241
app/api/preview_router.py                              27      7    74%   18, 24, 29, 34, 40, 45, 50
app/api/routes_consolidated.py                        218    113    48%   39-72, 78, 84, 90, 96, 109-112, 120-123, 131-134, 142-145, 153-156, 166-169, 179-182, 190-193, 201-204, 217-222, 230-235, 245-250, 260-265, 275-280, 293, 301, 309, 317, 325, 333, 341, 353-358, 369-371, 377, 383, 389, 395, 401, 407, 413, 423, 429, 435, 441, 449-452, 463-466, 474, 487-490, 498-501, 509-512
app/api/v1/router.py                                   78      0   100%
app/api/verification/__init__.py                        5      0   100%
app/api/verification/bulk_purchase_endpoints.py        61     27    56%   54-107, 123-126, 140-143, 151-154
app/api/verification/carrier_endpoints.py              43     28    35%   26-53, 61-93
app/api/verification/consolidated_verification.py     156    108    31%   52, 58-76, 88-155, 161-183, 192-201, 209-255, 265-296
app/api/verification/pricing.py                        35     24    31%   25-80
app/api/verification/purchase_endpoints.py            108     89    18%   42-241
app/api/verification/router.py                         16      0   100%
app/api/verification/status_polling.py                 76     53    30%   26-27, 33-95, 101-133, 147-159, 169-172, 184-198
app/api/verification/textverified_endpoints.py         62     45    27%   34-72, 98-106, 119-120, 138-184
app/core/__init__.py                                    5      0   100%
app/core/api_versioning.py                             26     26     0%   3-50
app/core/async_processing.py                           94     94     0%   3-192
app/core/auth_security.py                              76     40    47%   56-71, 76-85, 95-107, 112-138, 151-166
app/core/auto_scaling.py                               14     14     0%   3-32
app/core/config.py                                    126     24    81%   126, 134, 138-140, 149, 157-160, 178-200, 226-227
app/core/config_secrets.py                             85     85     0%   3-205
app/core/constants.py                                  25     25     0%   4-58
app/core/csrf_protection.py                            12     12     0%   3-23
app/core/custom_exceptions.py                          14      0   100%
app/core/database.py                                   19      8    58%   13, 32-36, 43-44, 49
app/core/database_indexes.py                           32     32     0%   3-62
app/core/database_optimization.py                      32     32     0%   3-102
app/core/dependencies.py                               60     39    35%   24-31, 42-53, 58-63, 71-74, 82-85, 92-102, 125-133
app/core/email_verification.py                         13     13     0%   3-28
app/core/encryption.py                                 31     31     0%   3-49
app/core/exceptions.py                                 14      0   100%
app/core/feature_flags.py                              66     66     0%   3-148
app/core/health_checks.py                              19     19     0%   3-38
app/core/health_monitor.py                             50     50     0%   3-98
app/core/lifespan.py                                   93     83    11%   17-134
app/core/load_balancer.py                              17     17     0%   3-27
app/core/logging.py                                    16      2    88%   19-21
app/core/logging_config.py                             17     17     0%   3-42
app/core/metrics.py                                   165    165     0%   6-366
app/core/migration.py                                 114    114     0%   3-206
app/core/monitoring.py                                115    115     0%   3-263
app/core/openapi.py                                    12     12     0%   3-55
app/core/performance_monitor.py                        39     39     0%   3-63
app/core/query_optimization.py                         33     33     0%   3-57
app/core/rbac.py                                       35     35     0%   3-68
app/core/region_manager.py                             38     38     0%   3-86
app/core/secrets.py                                    83     46    45%   45-48, 53-54, 59-61, 67, 81-83, 86, 91-104, 114, 122-149, 154-177
app/core/secrets_audit.py                              35     35     0%   3-143
app/core/secrets_manager.py                           134    134     0%   3-227
app/core/security_config.py                            60     60     0%   3-193
app/core/security_hardening.py                        104    104     0%   6-259
app/core/session_manager.py                            30     30     0%   3-66
app/core/startup.py                                    80     68    15%   17-149, 154-184, 189-237, 242-257
app/core/tier_config.py                                34     20    41%   14-35, 57-94, 99-100, 105-175, 180
app/core/tier_config_simple.py                          1      0   100%
app/core/tier_helpers.py                               36     15    58%   42-45, 58-60, 72, 84, 88-92, 104, 125-131
app/core/token_manager.py                              18     10    44%   12-18, 28, 33-36, 41
app/core/unified_cache.py                             159    118    26%   23-31, 35-36, 40-41, 45-46, 50-52, 75-89, 93-95, 99-112, 116-129, 133-139, 144-159, 163-170, 174-192, 196, 201-223, 228-238, 249, 254-255, 260-261, 266-267, 272-273, 278-279
app/core/unified_error_handling.py                    199    138    31%   31-35, 42, 47, 54, 64-66, 73, 80, 85-93, 100, 107, 114, 123, 133-134, 138-168, 172-180, 186-224, 234, 305-312, 324-326, 340-342, 354-371, 387-404, 410-422, 428-442, 448-483, 491-495, 500-509, 529
app/core/unified_rate_limiting.py                     182    133    27%   31-34, 38-49, 53-55, 111, 116-124, 129-137, 142-162, 169-184, 188-189, 194-209, 215-280, 295-303, 307-327, 331, 338-339, 344-382
app/middleware/__init__.py                              4      0   100%
app/middleware/csp.py                                   8      8     0%   3-23
app/middleware/csrf_middleware.py                      28     18    36%   18-51, 55-71
app/middleware/exception_handler.py                   111    111     0%   3-312
app/middleware/logging.py                             169    138    18%   28-32, 42-64, 69-126, 132-150, 163-171, 176-201, 208-209, 218-282, 286, 290, 302-303, 316-327, 331-365, 370-386, 391-399
app/middleware/monitoring.py                           22     22     0%   3-66
app/middleware/prometheus.py                           14     14     0%   3-29
app/middleware/rate_limiting.py                       130    108    17%   23-34, 49-112, 118-127, 132-141, 149-153, 165-176, 180-204, 208, 223-228, 232-278, 283-302
app/middleware/security.py                            110     87    21%   16-17, 24-52, 57-111, 118-119, 124-149, 156-157, 162-185, 199-218, 222-256, 264-291
app/middleware/tier_validation.py                      55     55     0%   3-109
app/middleware/whitelabel.py                           16     16     0%   3-32
app/middleware/xss_protection.py                       20     14    30%   13-40
app/models/__init__.py                                 15      0   100%
app/models/affiliate.py                                28      0   100%
app/models/api_key.py                                  16      0   100%
app/models/audit_log.py                                11      0   100%
app/models/balance_transaction.py                      13      1    92%   24
app/models/base.py                                     18      5    72%   24-26, 30, 34
app/models/blacklist.py                                18     18     0%   3-45
app/models/commission.py                               37      0   100%
app/models/enterprise.py                               22      0   100%
app/models/forwarding.py                               13     13     0%   3-29
app/models/kyc.py                                     106    106     0%   3-191
app/models/notification.py                             16      1    94%   27
app/models/payment.py                                  15     15     0%   3-23
app/models/preferences.py                              12     12     0%   3-26
app/models/pricing.py                                  68     68     0%   3-102
app/models/pricing_template.py                         59      2    97%   15-16
app/models/refund.py                                   17      0   100%
app/models/reseller.py                                 58      0   100%
app/models/sms_forwarding.py                           16     16     0%   3-28
app/models/sms_message.py                              15     15     0%   3-22
app/models/subscription_tier.py                        29      0   100%
app/models/system.py                                   45      0   100%
app/models/transaction.py                              21      0   100%
app/models/user.py                                     86      0   100%
app/models/user_preference.py                          13      0   100%
app/models/user_quota.py                               14      0   100%
app/models/verification.py                             51      0   100%
app/models/waitlist.py                                  8      8     0%   3-13
app/models/whitelabel.py                               19      0   100%
app/models/whitelabel_enhanced.py                      43      0   100%
app/schemas/__init__.py                                15      0   100%
app/schemas/analytics.py                               49      0   100%
app/schemas/auth.py                                   105     20    81%   31-33, 38-40, 45-49, 71-73, 221-223, 228-230
app/schemas/kyc.py                                    135    135     0%   3-344
app/schemas/payment.py                                119     19    84%   17-21, 33-37, 42-44, 186-188, 293-295
app/schemas/responses.py                               30      0   100%
app/schemas/system.py                                  22      0   100%
app/schemas/tier.py                                    76     76     0%   3-113
app/schemas/tier_response.py                            8      0   100%
app/schemas/tier_validators.py                         98     98     0%   7-220
app/schemas/validators.py                             279    231    17%   13-19, 24-34, 41-48, 53-63, 68-76, 81-100, 105-112, 117-127, 132-154, 163-165, 170-172, 177-179, 184-186, 191-193, 198-215, 220-227, 234-236, 254-275, 280-305, 310-325, 330-339, 344-353, 360-371, 376-384, 389-395, 400-422, 427-434, 439-447, 452-469, 474-487, 493-510, 515-532, 537-550
app/schemas/verification.py                            86      3    97%   19-37, 43
app/schemas/verification_status.py                     40     40     0%   3-88
app/schemas/waitlist.py                                15     15     0%   3-22
app/services/__init__.py                               36     23    36%   12-13, 17-21, 25-29, 33-37, 42-43, 51, 56-58, 63-65, 70-72
app/services/adaptive_polling.py                       51     51     0%   3-97
app/services/affiliate_service.py                      30     20    33%   23-44, 48, 91-95, 114-128
app/services/alerting_service.py                       46     46     0%   3-92
app/services/analytics_service.py                      26     15    42%   11, 16-49, 65-81, 88-104
app/services/api_key_service.py                        40     28    30%   16-33, 38-55, 60-73
app/services/audit_service.py                          19     19     0%   3-48
app/services/auth_service.py                          148    117    21%   30, 35-53, 57-86, 91-93, 98, 102-110, 114-123, 127-133, 137-146, 150, 154-161, 165-166, 173-202, 206-218, 222-237, 241-250, 255
app/services/auto_topup_service.py                     38     38     0%   3-79
app/services/base.py                                   40     27    32%   16-17, 21-25, 29, 33, 37-48, 52-58, 62, 67
app/services/business_intelligence.py                  37     37     0%   3-82
app/services/cdn_service.py                            14     14     0%   3-49
app/services/commission_engine.py                      70     70     0%   3-184
app/services/compliance_service.py                     19     19     0%   3-93
app/services/credit_service.py                        113     94    17%   23, 37-42, 66-94, 127-169, 194-218, 245-276, 301-348, 372-398
app/services/currency_service.py                       20     20     0%   4-58
app/services/disaster_recovery.py                      25     25     0%   3-108
app/services/document_service.py                      190    190     0%   3-398
app/services/email_service.py                         104     75    28%   30, 44-62, 76-94, 108-126, 139-158, 167-174, 185-191, 245-250, 306-312
app/services/enterprise_service.py                     30     30     0%   3-72
app/services/error_handling.py                         69     69     0%   3-138
app/services/event_service.py                          27     27     0%   3-49
app/services/fraud_detection_service.py                23     23     0%   3-48
app/services/kyc_service.py                           189    189     0%   2-444
app/services/mfa_service.py                            22     22     0%   3-36
app/services/monitoring_service.py                     59     59     0%   3-169
app/services/notification_service.py                   83     63    24%   21, 47-63, 83-107, 140-151, 166-175, 190-205, 220-227, 242-253, 268-280, 291-301, 307-310
app/services/payment_service.py                       159    138    13%   24-25, 44-111, 127-184, 196-209, 220-269, 285-296, 313-337, 367-394, 422-467
app/services/paystack_service.py                       96     72    25%   28, 48-90, 101-134, 146-156, 167-187, 195-221, 229
app/services/pricing_calculator.py                     53     53     0%   3-128
app/services/pricing_template_service.py              118    118     0%   3-349
app/services/quota_service.py                          55     55     0%   3-142
app/services/refund_service.py                        105     87    17%   23-24, 44-97, 112-177, 191-198, 223-245, 276-293, 305-336
app/services/reseller_service.py                       95     95     0%   3-329
app/services/smart_routing.py                          30     30     0%   3-77
app/services/sms_gateway.py                            18     18     0%   3-37
app/services/sms_polling_service.py                   123    123     0%   3-206
app/services/telegram_service.py                       19     19     0%   3-37
app/services/textverified_service.py                  277    244    12%   5-6, 23-58, 68-85, 95-100, 110-112, 120-132, 136-139, 145-148, 158-180, 196-218, 233-275, 283-303, 311-344, 351-356, 366-407, 417-422, 439-461, 468-478, 485-491, 498, 511-535, 542-551, 559-563, 575-588
app/services/tier_manager.py                           64     48    25%   18, 22-34, 38-50, 54-57, 70-94, 98-120, 124, 129
app/services/transaction_service.py                    31     31     0%   3-85
app/services/translation_service.py                    25     25     0%   3-41
app/services/verification_pricing_service.py           27     27     0%   3-45
app/services/voice_polling_service.py                  79     79     0%   3-139
app/services/webhook_notification_service.py           70     70     0%   3-147
app/services/webhook_service.py                        38     22    42%   22-25, 29, 33-59, 63
app/services/whatsapp_service.py                       20     20     0%   3-50
app/services/whitelabel_enhanced.py                    69     69     0%   3-244
app/services/whitelabel_service.py                     20     20     0%   3-61
app/utils/__init__.py                                   0      0   100%
app/utils/data_masking.py                             109    109     0%   3-224
app/utils/email.py                                     60     60     0%   3-177
app/utils/exception_handling.py                       101    101     0%   3-217
app/utils/function_refactor.py                         60     60     0%   3-102
app/utils/log_sanitization.py                          45     45     0%   3-93
app/utils/path_security.py                             39     39     0%   3-97
app/utils/performance.py                               18     18     0%   3-33
app/utils/pricing_display.py                           13     13     0%   4-36
app/utils/response_validator.py                        30     30     0%   3-79
app/utils/sanitization.py                              39     32    18%   10-21, 26-33, 38-52, 57-71
app/utils/security.py                                  50     34    32%   16-18, 23-28, 33-42, 47-51, 56-57, 62, 67-72, 77-80, 85-95
app/utils/sql_safety.py                                61     61     0%   3-119
app/utils/timezone_utils.py                            52     52     0%   3-104
---------------------------------------------------------------------------------
TOTAL                                               14119  10897    23%
Coverage HTML written to dir htmlcov

FAIL Required test coverage of 70% not reached. Total coverage: 22.82%
=========================== short test summary info ============================
ERROR tests/unit/test_auth_service.py::TestAuthService::test_register_user_success
ERROR tests/unit/test_auth_service.py::TestAuthService::test_register_user_duplicate_email
ERROR tests/unit/test_auth_service.py::TestAuthService::test_register_user_with_referral
ERROR tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_success
ERROR tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_wrong_password
ERROR tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_not_found
ERROR tests/unit/test_auth_service.py::TestAuthService::test_create_and_verify_api_key
ERROR tests/unit/test_auth_service.py::TestAuthService::test_verify_api_key_invalid
ERROR tests/unit/test_auth_service.py::TestAuthService::test_deactivate_api_key
ERROR tests/unit/test_auth_service.py::TestAuthService::test_reset_password_flow
ERROR tests/unit/test_auth_service.py::TestAuthService::test_reset_password_invalid_token
============================= 11 errors in 58.70s ==============================
